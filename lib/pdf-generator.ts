import { PDFDocument, rgb, StandardFonts } from "pdf-lib";

export interface PDFGenerateOptions {
  title: string;
  content: string;
  metadata?: {
    author?: string;
    subject?: string;
    keywords?: string[];
    creator?: string;
  };
}

/**
 * Generate a PDF document from text content
 */
export async function generatePDF(
  options: PDFGenerateOptions
): Promise<Buffer> {
  try {
    const pdfDoc = await PDFDocument.create();

    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    const page = pdfDoc.addPage([595, 842]); // A4 size
    const { width, height } = page.getSize();

    const titleSize = 24;
    page.drawText(options.title, {
      x: 50,
      y: height - 50,
      size: titleSize,
      font: boldFont,
      color: rgb(0, 0, 0),
    });

    page.drawLine({
      start: { x: 50, y: height - 60 },
      end: { x: width - 50, y: height - 60 },
      thickness: 2,
      color: rgb(0, 0, 0),
    });

    const contentSize = 12;
    const lineHeight = contentSize * 1.5;
    const maxWidth = width - 100;

    const paragraphs = options.content.split("\n");
    let yPosition = height - 100;
    for (const para of paragraphs) {
      const words = para.split(" ");
      let currentLine = "";
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const testWidth = font.widthOfTextAtSize(testLine, contentSize);
        if (testWidth > maxWidth && currentLine) {
          if (yPosition < 50) {
            const newPage = pdfDoc.addPage([595, 842]);
            yPosition = newPage.getSize().height - 50;
            newPage.drawText(currentLine, {
              x: 50,
              y: yPosition,
              size: contentSize,
              font: font,
              color: rgb(0, 0, 0),
            });
          } else {
            page.drawText(currentLine, {
              x: 50,
              y: yPosition,
              size: contentSize,
              font: font,
              color: rgb(0, 0, 0),
            });
          }
          yPosition -= lineHeight;
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) {
        if (yPosition < 50) {
          const newPage = pdfDoc.addPage([595, 842]);
          yPosition = newPage.getSize().height - 50;
          newPage.drawText(currentLine, {
            x: 50,
            y: yPosition,
            size: contentSize,
            font: font,
            color: rgb(0, 0, 0),
          });
        } else {
          page.drawText(currentLine, {
            x: 50,
            y: yPosition,
            size: contentSize,
            font: font,
            color: rgb(0, 0, 0),
          });
        }
        yPosition -= lineHeight;
      }
      yPosition -= lineHeight / 2;
    }

    pdfDoc.setTitle(options.title);
    pdfDoc.setAuthor(options.metadata?.author || "PDF Signature System");
    pdfDoc.setSubject(options.metadata?.subject || "Generated Report");
    pdfDoc.setKeywords(options.metadata?.keywords || ["report", "generated"]);
    pdfDoc.setProducer("PDF Signature System");
    pdfDoc.setCreator(options.metadata?.creator || "PDF Signature System");
    pdfDoc.setCreationDate(new Date());
    pdfDoc.setModificationDate(new Date());

    const pdfBytes = await pdfDoc.save();

    return Buffer.from(pdfBytes);
  } catch (error) {
    throw new Error("Failed to generate PDF: " + (error as Error).message);
  }
}

/**
 * Generate sample report PDF
 */
export async function generateSampleReport(
  reportTitle: string,
  organizationName: string,
  createdBy: string
): Promise<Buffer> {
  const content = `
This is a sample report generated by ${organizationName}.

Report Details:
- Generated by: ${createdBy}
- Date: ${new Date().toLocaleString("id-ID")}
- Report Type: Security Assessment

Summary:
This document contains important information regarding the security assessment conducted on the specified systems. The assessment was performed in accordance with industry best practices and standards.

Findings:
1. System configuration has been reviewed and documented
2. Security protocols are in place and functioning correctly
3. Access controls have been verified and tested
4. Encryption mechanisms are properly implemented

Recommendations:
- Continue regular security audits
- Maintain up-to-date documentation
- Keep all systems patched and updated
- Provide ongoing security training for staff

This document can be digitally signed to ensure authenticity and integrity.

---
End of Report
  `.trim();

  return generatePDF({
    title: reportTitle,
    content,
    metadata: {
      author: createdBy,
      subject: "Security Assessment Report",
      keywords: ["report", "security", "assessment"],
      creator: organizationName,
    },
  });
}
