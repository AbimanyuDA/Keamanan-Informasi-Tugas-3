import { PDFDocument } from "pdf-lib";
// Use dynamic require for node-signpdf helpers to avoid type definition mismatches
const nodeSignpdf = require("node-signpdf");
const { plainAddPlaceholder } = require("node-signpdf/dist/helpers");
const sign = nodeSignpdf.sign;

/**
 * Normalize a PDF by re-saving pages with pdf-lib to avoid xref-streams / object streams
 * which `node-signpdf`'s placeholder helper may not support.
 */
async function normalizePdfBuffer(pdfBuffer: Buffer): Promise<Buffer> {
  try {
    // First try qpdf (faster and preserves content) to disable object streams
    try {
      const { execSync } = require("child_process");
      const os = require("os");
      const { writeFileSync, readFileSync, unlinkSync } = require("fs");
      const { join } = require("path");
      const inPath = join(os.tmpdir(), `in_pdf_${Date.now()}.pdf`);
      const outPath = join(os.tmpdir(), `out_pdf_${Date.now()}.pdf`);
      writeFileSync(inPath, pdfBuffer);
      // --object-streams=disable creates classic xref table
      execSync(`qpdf --object-streams=disable "${inPath}" "${outPath}"`, { stdio: "ignore" });
      const out = readFileSync(outPath);
      try {
        unlinkSync(inPath);
        unlinkSync(outPath);
      } catch (e) {}
      return out;
    } catch (e) {
      // qpdf not available or failed, fall back to pdf-lib re-save
      const pdfDoc = await PDFDocument.load(pdfBuffer);
      const newDoc = await PDFDocument.create();
      const pages = await newDoc.copyPages(pdfDoc, pdfDoc.getPageIndices());
      pages.forEach((p) => newDoc.addPage(p));
      return Buffer.from(await newDoc.save());
    }
  } catch (e) {
    // If normalization fails, return original buffer
    return pdfBuffer;
  }
}

/**
 * Sign a PDF using node-signpdf so the signature is valid in Adobe Reader and locked from editing.
 * @param pdfBuffer Buffer of the unsigned PDF
 * @param p12Buffer Buffer of the PKCS#12 (PFX) file containing private key and certificate
 * @param passphrase Passphrase for the P12 file
 * @returns Buffer of the signed PDF
 */
export async function signPdfWithNodeSignpdf(
  pdfBuffer: Buffer,
  p12Buffer: Buffer,
  passphrase: string
): Promise<Buffer> {
  // Try inserting placeholder directly; if it fails (e.g., xref stream PDFs),
  // normalize PDF first and retry.
  let pdfWithPlaceholder: Buffer;
  try {
    pdfWithPlaceholder = plainAddPlaceholder({
      pdfBuffer,
      reason: "Document signed digitally",
      signatureLength: 8192,
    });
  } catch (err) {
    // Normalize PDF (rebuild without object streams) and try again
    const normalized = await normalizePdfBuffer(pdfBuffer);
    pdfWithPlaceholder = plainAddPlaceholder({
      pdfBuffer: normalized,
      reason: "Document signed digitally",
      signatureLength: 8192,
    });
  }

  // Sign the PDF
  const signedPdf = sign(pdfWithPlaceholder, p12Buffer, { passphrase });
  return signedPdf;
}

/**
 * (Optional) Set PDF permissions to prevent editing (using pdf-lib)
 * @param pdfBuffer Buffer of the signed PDF
 * @returns Buffer of the locked PDF
 */
export async function lockPdfEditing(pdfBuffer: Buffer): Promise<Buffer> {
  const pdfDoc = await PDFDocument.load(pdfBuffer);
  // pdf-lib does not support setting permissions directly, but you can set metadata
  pdfDoc.setModificationDate(new Date());
  pdfDoc.setProducer("PDF Signature System");
  pdfDoc.setCreator("PDF Signature System");
  // Save and return
  return Buffer.from(await pdfDoc.save());
}
