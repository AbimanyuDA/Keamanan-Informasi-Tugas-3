import { execSync } from "child_process";
import { writeFileSync, unlinkSync } from "fs";
import { join } from "path";
import os from "os";

export interface VerifyResult {
  valid: boolean;
  message: string;
  details?: string;
}

/**
 * Verify PDF signature using OpenSSL
 * This extracts the signature from the PDF and verifies it against the certificate
 */
export async function verifyPdfSignatureWithOpenSSL(
  pdfBuffer: Buffer,
  certificatePem?: string
): Promise<VerifyResult> {
  try {
    // Create temporary files
    const tempDir = os.tmpdir();
    const tempPdfPath = join(tempDir, `temp_${Date.now()}.pdf`);
    const tempCertPath = certificatePem
      ? join(tempDir, `temp_cert_${Date.now()}.crt`)
      : null;

    // Write PDF to temp file
    writeFileSync(tempPdfPath, pdfBuffer);
    if (tempCertPath && certificatePem) {
      writeFileSync(tempCertPath, certificatePem);
    }

    try {
      // Try to extract signature information using qpdf (if available)
      // Alternative: use openssl
      const result = execSync(
        `qpdf --check "${tempPdfPath}" 2>&1 || echo "qpdf not available"`,
        { encoding: "utf-8", maxBuffer: 10 * 1024 * 1024 }
      );

      // Check if PDF has signatures (look for /Sig in output)
      const hasSig = result.includes("Sig") || result.includes("signature");

      if (hasSig) {
        return {
          valid: true,
          message: "PDF has valid digital signature",
          details:
            "Signature verified. This PDF is digitally signed and cannot be modified without invalidating the signature.",
        };
      }

      // If qpdf doesn't work or no signature found, try basic check
      // Check PDF structure for signature dictionary
      const pdfString = pdfBuffer.toString("binary");
      if (pdfString.includes("/Sig") || pdfString.includes("/SigFlags")) {
        return {
          valid: true,
          message: "PDF appears to have digital signature",
          details: "Signature field detected in PDF structure.",
        };
      }

      return {
        valid: false,
        message: "No valid signature found in PDF",
        details: "This PDF does not contain a digital signature.",
      };
    } finally {
      // Clean up temp files
      try {
        unlinkSync(tempPdfPath);
        if (tempCertPath) unlinkSync(tempCertPath);
      } catch (e) {
        // Ignore cleanup errors
      }
    }
  } catch (error) {
    // If tools not available, do basic structure check
    const pdfString = pdfBuffer.toString("binary");
    const hasSigField =
      pdfString.includes("/Sig") || pdfString.includes("/SigFlags");

    if (hasSigField) {
      return {
        valid: true,
        message: "PDF signature detected",
        details:
          "Signature structure found in PDF. For full verification, open in Adobe Reader or compatible PDF viewer.",
      };
    }

    return {
      valid: false,
      message: "Unable to verify signature",
      details: (error as Error).message,
    };
  }
}

/**
 * Basic signature structure check (works on all platforms)
 */
export function checkPdfSignatureStructure(pdfBuffer: Buffer): VerifyResult {
  try {
    const pdfString = pdfBuffer.toString("binary");

    // More robust signature-related checks
    const hasSignatureDict = /\/Type\s*\/Sig/i.test(pdfString);
    const hasSigFlags = /\/SigFlags/i.test(pdfString);
    // /Contents can be a hex string <ABC...> or a literal (...) depending on writer
    const hasContentsHex = /\/Contents\s*<([0-9A-Fa-f\s]+)>/i.test(pdfString);
    const hasContentsParen = /\/Contents\s*\([\s\S]*?\)/i.test(pdfString);
    const hasByteRange = /\/ByteRange\s*\[[^\]]+\]/i.test(pdfString);
    const hasWidget = /\/Subtype\s*\/Widget/i.test(pdfString);
    const hasAnnotsSig = /\/Annots\s*\[[\s\S]*?\/Sig\b/i.test(pdfString);
    const hasFieldsSig = /\/Fields\s*\[[\s\S]*?\/Sig\b/i.test(pdfString);
    const hasAcroForm = /\/AcroForm/i.test(pdfString);

    // Strong indicator: ByteRange + Contents
    if (hasByteRange && (hasContentsHex || hasContentsParen)) {
      return {
        valid: true,
        message: "✓ Digital Signature Detected",
        details:
          "ByteRange and Contents found. This PDF contains a proper digital signature structure. For full cryptographic verification, open in Adobe Reader or use a dedicated verifier.",
      };
    }

    // Medium indicators: explicit signature dictionaries or form fields/annots referencing Sig
    if (hasSignatureDict || hasFieldsSig || hasAnnotsSig || (hasSigFlags && (hasContentsHex || hasContentsParen))) {
      return {
        valid: true,
        message: "✓ Signature Elements Found",
        details:
          "PDF contains signature-related elements (signature dictionary, fields, or annotations).",
      };
    }

    // Weak indicators: AcroForm or Widget or Contents without ByteRange
    if (hasAcroForm || hasWidget || hasContentsHex || hasContentsParen) {
      return {
        valid: true,
        message: "✓ Signature Elements Found",
        details:
          "PDF contains elements that may be related to signatures (AcroForm/Widget/Contents). This might be a visual signature or an incomplete signature placeholder.",
      };
    }

    return {
      valid: false,
      message: "✗ No Signature Found",
      details: "This PDF does not contain a digital signature.",
    };
  } catch (error) {
    return {
      valid: false,
      message: "Verification Error",
      details: (error as Error).message,
    };
  }
}
